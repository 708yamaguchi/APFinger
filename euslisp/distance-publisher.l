#!/usr/bin/env roseus

(require "package://fetcheus/fetch-interface.l")

(ros::load-ros-manifest "roseus")
(ros::load-ros-manifest "fetch_driver_msgs")
(ros::load-ros-manifest "APFinger")

(defclass distance-publisher
  :super propertied-object
  :slots (calib-coef-
          default-calib-coef-
          default-init-proximities-
          fingers-
          for-rviz-
          frame-list-
          init-proximities-
          initp-
          proximity-marker-left-
          proximity-marker-right-
          proximities-raw-
          proximities-calibrated-
          proximity-initp-
          sensor-coords-left-
          sensor-coords-right-))

(defmethod distance-publisher
  (:init (&rest args &key (sensorp t) (for-rviz nil))
    ;; DO :init FIRST
    (setq for-rviz- for-rviz)
    (setq fingers- (list "/left" "/right"))
    (setq frame-list- (list "/top" "/side0" "/side1" "/side2" "/side3"))
    (when sensorp
      (ros::advertise "/proximity_marker_left" visualization_msgs::MarkerArray 1)
      (ros::advertise "/proximity_marker_right" visualization_msgs::MarkerArray 1)
      (dolist (l/r fingers-)
        (dolist (frame frame-list-)
          (ros::advertise (format nil "/proximity_distance~A~A" l/r frame) APFinger::ProximityDistances 1)
          ;; (if (equal frame "/top")
          ;;   (dotimes (i 4)
          ;;     (ros::advertise (format nil "/proximity_marker~A~A/~A" l/r frame i) visualization_msgs::Marker 1))
          ;;   (dotimes (i 8)
          ;;     (ros::advertise (format nil "/proximity_marker~A~A/~A" l/r frame i) visualization_msgs::Marker 1)))
          ))
      (setq proximity-marker-left- nil)
      (setq proximity-marker-right- nil)
      (send self :set-proximity-marker)
      (ros::subscribe "/set_init_proximities" std_msgs::Empty #'send self :cb-init-proximities)
      (dolist (l/r fingers-)
        (dolist (frame frame-list-)
          (ros::subscribe (format nil "/proximity_sensors~A~A" l/r frame) APFinger::ProximityArray #'send self :cb-set-proximities l/r)))
      (setq proximities-raw- (make-hash-table :test #'equal))
      (setq proximities-calibrated- (make-hash-table :test #'equal))
      (setq default-init-proximities- (make-hash-table :test #'equal))
      (setq init-proximities- (make-hash-table :test #'equal))
      (setq default-calib-coef- (make-hash-table :test #'equal))
      (setq calib-coef- (make-hash-table :test #'equal))
      (dolist (l/r fingers-)
        (sethash l/r proximities-raw- (make-hash-table :test #'equal))
        (sethash l/r proximities-calibrated- (make-hash-table :test #'equal))
        (sethash l/r default-init-proximities- (make-hash-table :test #'equal))
        (sethash l/r init-proximities- (make-hash-table :test #'equal))
        (sethash l/r default-calib-coef- (make-hash-table :test #'equal))
        (sethash l/r calib-coef- (make-hash-table :test #'equal)))


      ;; memo : coef-list is arranged like below
      ;; ((left top) (left side0) (left side1) (left side2) (left side3)
      ;;  (right top) (right side0) (right side1) (right side2) (right side3))

      ;; TODO : set correct value of coef-list
      (unless (ros::has-param "/left/top/coef")
        (error "cannot load rosparam for proximity sensors~%"))
      (let ((i 0) (prox-list) (coef-list) (dist-list) (prox-arr))
        ;; get default proximity value from rosparam
        (dolist (l/r fingers-)
          (dolist (frame frame-list-)
            (setq prox-list (append prox-list
                                    (list (ros::get-param (format nil "~A~A/default_prox" l/r frame)))
                                    ))))
        ;; get default proximity coef from rosparam
        (dolist (l/r fingers-)
          (dolist (frame frame-list-)
            (setq coef-list (append coef-list
                                    (list (ros::get-param (format nil "~A~A/coef" l/r frame)))
                                    ))))
        (setq dist-list (append (list (list *inf* *inf* *inf* *inf*))
                                (make-list 4 :initial-element (make-list 8 :initial-element *inf*))
                                (list (list *inf* *inf* *inf* *inf*))
                                (make-list 4 :initial-element (make-list 8 :initial-element *inf*))))
        (dolist (l/r fingers-)
          (dolist (frame frame-list-)
            ;; (sethash frame (gethash l/r init-proximities-) (elt default-init-proximities- i))
            (setq prox-arr (instance APFinger::ProximityArray :init))
            (send prox-arr :proximities (mapcar #'(lambda(x) (let ((prox (instance APFinger::Proximity :init))) (send prox *type* x) prox)) (elt prox-list i)))
            (send (send prox-arr :header) :frame_id frame)
            (sethash frame (gethash l/r default-init-proximities-) prox-arr)
            (sethash frame (gethash l/r default-calib-coef-) (elt coef-list i))
            (setq prox-arr (copy-object prox-arr))
            (send prox-arr :proximities (mapcar #'(lambda(x) (let ((prox (instance APFinger::Proximity :init))) (send prox *type* x) prox)) (elt dist-list i)))
            (sethash frame (gethash l/r proximities-calibrated-) prox-arr)
            (setq i (+ i 1)))))
      (setq init-proximities- (copy-object default-init-proximities-))
      (setq proximities-raw- (copy-object default-init-proximities-))
      (setq proximities-calibrated- (copy-object default-init-proximities-))
      (setq calib-coef- (copy-object default-calib-coef-))
      (send self :set-init-proximities)
      )
    self)
  (:set-init-proximities (&key (use-default-init-proximities nil))
    (ros::spin-once)
    (when (null (gethash "/top" (gethash "/left" proximities-raw-)))
      (error "Proximity value is null. Proximity topic may not be published yet.~%"))
    (if use-default-init-proximities
      (setq init-proximities- (copy-object default-init-proximities-))
      (setq init-proximities- (copy-object proximities-raw-)))
    (setq initp- t))
  (:cb-set-proximities (finger msg)
    ;; set raw sensor value to hash table
    (sethash (send (send msg :header) :frame_id) (gethash finger proximities-raw-) msg)
    ;; set calibrated sensor value to hash table
    (let ((prox-arr (copy-object msg)) (frame (send (send msg :header) :frame_id)) (coef nil) (init-prox nil) (i 0))
      (dolist (prox (send prox-arr :proximities))
        (setq coef (nth i (gethash frame (gethash finger calib-coef-))))
        (setq init-prox (send (nth i (send (gethash frame (gethash finger init-proximities-)) :proximities)) *type*))
        ;; TODO : change how to calculate proximities-calibrated-
        (if (> (send prox *type*) init-prox)
          (send prox *type* (expt (/ (- (send prox *type*) init-prox) coef) -0.5)) ;; NOTE : this is main program to convert sensor value to distance
          (send prox *type* *inf*))
        (setq i (+ i 1)))
      (sethash frame (gethash finger proximities-calibrated-) prox-arr))
    ;; publish distance calculated from proximtiy values
    (send self :publish-distance)
    ;; publish rviz marker for proximity sensor
    (if (and for-rviz- (equal (send (send msg :header) :frame_id) "/top") (equal finger "/right")) (send self :publish-marker)) ;; tamani segmentation fault in (setq lmsg msg)
    )
  (:get-proximities (finger frame &key (type :calibrated))
    (let ((pass-sec (- (send (ros::time-now) :sec) (send (send (send (gethash frame (gethash finger proximities-raw-)) :header) :stamp) :sec))))
      (if (and (null for-rviz-)
               (> pass-sec 30))
        (error (format nil "new proximity msgs have not come for ~A seconds. Check wiring." pass-sec))))
    (cond
      ((equal type :calibrated)
       (send self :calib-proximity finger frame))
      ((equal type :raw) (gethash frame (gethash finger proximities-raw-)))
      ((equal type :init) (gethash frame (gethash finger init-proximities-)))))
  (:calib-proximity (finger frame)
    (gethash frame (gethash finger proximities-calibrated-)))
  (:get-proximity-value (finger frame &key (type :calibrated))
    (let ((prox-arr (send self :get-proximities finger frame :type type)) (prox-list nil))
      (dolist (prox (send prox-arr :proximities))
        (setq prox-list (append prox-list (list (send prox *type*)))))
      prox-list))
  (:publish-distance ()
    (when initp-
      (dolist (l/r fingers-)
        (dolist (frame frame-list-)
          (let ((distance-msg (instance APFinger::ProximityDistances :init)))
            (send distance-msg :data (coerce (send self :get-proximity-value l/r frame :type :calibrated) float-vector))
            (send distance-msg :header (send (send self :get-proximities l/r frame :type :raw) :header))
            (ros::publish (format nil "/proximity_distance~A~A" l/r frame) distance-msg))))))
  ;; len : length of sensor area
  (:make-sensor-arr (frame len)
    (let (cube cube-list (co (make-cascoords)))
      (if (equal frame "/top")
        (progn
          (dotimes (i 4)
            (setq cube-list (append cube-list (list (make-cube (+ len 1.0) (+ len 1.0) (* len 0.5))))))
          (send (nth 0 cube-list) :locate (float-vector (* len -0.5) (* len -0.5) 0))
          (send (nth 0 cube-list) :set-color #f(1 0 0))
          (send (nth 1 cube-list) :locate (float-vector (* len 0.5) (* len -0.5) 0))
          (send (nth 2 cube-list) :locate (float-vector (* len -0.5) (* len 0.5) 0))
          (send (nth 3 cube-list) :locate (float-vector (* len 0.5) (* len 0.5) 0))
          (dotimes (i 4)
            (send co :assoc (nth i cube-list)))
          (list cube-list co)
          )
        (progn
          (dotimes (i 8)
            (setq cube-list (append cube-list (list (make-cube len len (* len 0.5))))))

          (send (nth 0 cube-list) :set-color #f(1 0 0))
          (send (nth 0 cube-list) :locate (float-vector (* len -0.5) (* len -1.5) 0))
          (send (nth 1 cube-list) :locate (float-vector (* len 0.5) (* len -1.5) 0))
          (send (nth 2 cube-list) :locate (float-vector (* len -0.5) (* len -0.5) 0))
          (send (nth 3 cube-list) :locate (float-vector (* len 0.5) (* len -0.5) 0))
          (send (nth 4 cube-list) :locate (float-vector (* len -0.5) (* len 0.5) 0))
          (send (nth 5 cube-list) :locate (float-vector (* len 0.5) (* len 0.5) 0))
          (send (nth 6 cube-list) :locate (float-vector (* len -0.5) (* len 1.5) 0))
          (send (nth 7 cube-list) :locate (float-vector (* len 0.5) (* len 1.5) 0))
          (if (equal frame "/side0")
              (send (nth 0 cube-list) :set-color #f(0 0 1)))
          (dotimes (i 8)
            (send co :assoc (nth i cube-list)))
          ;; (instance bodyset :init (make-cascoords) :bodies cube-list)
          (list cube-list co)))
      ))
  (:set-proximity-marker ()
    (let (arr co-parent co arr-list (len 12))
      ;; for left finger
      (setq proximity-marker-left- nil)
      (setq arr (send self :make-sensor-arr "/top" len))
      (setq co-parent (cadr arr))
      (setq arr-list (append arr-list (car arr)))
      (setq arr (send self :make-sensor-arr "/side0" len))
      (setq co (cadr arr))
      (send co-parent :assoc co)
      (send co :rotate pi/2 :x :world)
      (send co :rotate pi/2 :z :world)
      (send co :locate (float-vector len 0 (* -2 len)) :world)
      (setq arr-list (append arr-list (car arr)))
      (setq arr (send self :make-sensor-arr "/side1" len))
      (setq co (cadr arr))
      (send co-parent :assoc co)
      (send co :rotate pi/2 :x :world)
      (send co :rotate pi :z :world)
      (send co :locate (float-vector 0 len (* -2 len)) :world)
      (setq arr-list (append arr-list (car arr)))
      (setq arr (send self :make-sensor-arr "/side2" len))
      (setq co (cadr arr))
      (send co-parent :assoc co)
      (send co :rotate pi/2 :x :world)
      (send co :rotate -pi/2 :z :world)
      (send co :locate (float-vector (* -1 len) 0 (* -2 len)) :world)
      (setq arr-list (append arr-list (car arr)))
      (setq arr (send self :make-sensor-arr "/side3" len))
      (setq co (cadr arr))
      (send co-parent :assoc co)
      (send co :rotate pi/2 :x :world)
      (send co :locate (float-vector 0 (* -1 len) (* -2 len)) :world)
      (setq arr-list (append arr-list (car arr)))
      (setq sensor-coords-left- co-parent)
      (setq proximity-marker-left- arr-list)
      (dolist (c (cdr proximity-marker-left-))
        (send (car proximity-marker-left-) :assoc c))
      (send (send (car proximity-marker-left-) :parent) :dissoc (car proximity-marker-left-))
      (send (car proximity-marker-left-) :move-coords
            (make-coords :pos (float-vector 0 10 0) :rpy (float-vector pi/2 0 pi/2)) (make-coords :pos (float-vector 0 0 -40)))

      ;; for right finger
      (setq arr nil)
      (setq arr-list nil)
      (setq proximity-marker-right- nil)
      (setq arr (send self :make-sensor-arr "/top" len))
      (setq co-parent (cadr arr))
      (setq arr-list (append arr-list (car arr)))
      (setq arr (send self :make-sensor-arr "/side0" len))
      (setq co (cadr arr))
      (send co-parent :assoc co)
      (send co :rotate pi/2 :x :world)
      (send co :rotate -pi/2 :z :world)
      (send co :locate (float-vector (* -1 len) 0 (* -2 len)) :world)
      (setq arr-list (append arr-list (car arr)))
      (setq arr (send self :make-sensor-arr "/side1" len))
      (setq co (cadr arr))
      (send co-parent :assoc co)
      (send co :rotate pi/2 :x :world)
      (send co :rotate pi :z :world)
      (send co :locate (float-vector 0 len (* -2 len)) :world)
      (setq arr-list (append arr-list (car arr)))
      (setq arr (send self :make-sensor-arr "/side2" len))
      (setq co (cadr arr))
      (send co-parent :assoc co)
      (send co :rotate pi/2 :x :world)
      (send co :rotate pi/2 :z :world)
      (send co :locate (float-vector len 0 (* -2 len)) :world)
      (setq arr-list (append arr-list (car arr)))
      (setq arr (send self :make-sensor-arr "/side3" len))
      (setq co (cadr arr))
      (send co-parent :assoc co)
      (send co :rotate pi/2 :x :world)
      (send co :locate (float-vector 0 (* -1 len) (* -2 len)) :world)
      (setq arr-list (append arr-list (car arr)))
      (setq sensor-coords-right- co-parent)
      (setq proximity-marker-right- arr-list)
      (dolist (c (cdr proximity-marker-right-))
        (send (car proximity-marker-right-) :assoc c))
      (send (send (car proximity-marker-right-) :parent) :dissoc (car proximity-marker-right-))
      (send (car proximity-marker-right-) :move-coords
            (make-coords :pos (float-vector 0 -10 0) :rpy (float-vector pi/2 0 pi/2)) (make-coords :pos (float-vector 0 0 -40)))
      ))
  (:publish-marker()
    (when initp-
      ;; use for open/close of gripper
      (dolist (l/r fingers-)
        (let ((i 0)
              (marker-array nil)
              (sensor-marker nil))
          (cond ((equal l/r "/left") (setq sensor-marker proximity-marker-left-))
                ((equal l/r "/right") (setq sensor-marker proximity-marker-right-)))
          (dolist (frame frame-list-)
            (dolist (distance (send self :get-proximity-value l/r frame :type :calibrated))
              (setq marker-array (append marker-array
                                         (list (cube->marker-msg (elt sensor-marker i)
                                                                 (instance std_msgs::header :init :stamp (ros::time-now) :frame_id (format nil "~A_gripper_finger_link" (subseq l/r 0 2)))
                                                                 :color (float-vector 1 (/ (min distance 40) 50.0) (/ (min distance 40) 50.0))
                                                                 :id i))))
              (setq i (+ i 1))))
          (ros::publish (format nil "/proximity_marker_~A" (subseq l/r 1))
                        (instance visualization_msgs::MarkerArray :init :markers marker-array)))
        )))
  (:cb-init-proximities (msg)
    (setq init-proximities- (copy-object proximities-raw-))
    (dolist (l/r fingers-)
      (dolist (frame frame-list-)
        (ros::set-param (format nil "~A~A/default_prox" l/r frame)
                        (mapcar #'(lambda (x) (send x *type*)) (send (gethash frame (gethash l/r init-proximities-)) :proximities))))))
  )


(defun init (&optional (sensorp t) (for-rviz nil))
  (when (not (boundp '*dp*))
    (setq *dp* (instance distance-publisher :init :sensorp sensorp :for-rviz for-rviz)))
  (ros::spin-once))


(defun main ()
  ;; set *type* :proximity to use raw sensor value
  ;; set *type* :average to use low-pass-filtered sensor value
  ;; (setq *type* :average)
  (setq *type* :proximity)
  (init t t)
  (ros::spin-once)
  (send *dp* :set-init-proximities)
  (ros::rate 100)
  (while t
    (ros::spin-once)
    (ros::sleep)))
