(require "package://fetcheus/fetch-interface.l")

(defun irt ()
  (send *irtviewer* :draw-objects))
(defun send-av (&optional (time 5000))
  (send *ri* :angle-vector (send *fetch* :angle-vector) time))
(defun look-at-hand (&optional (time 3000))
  (send *fetch* :angle-vector (send *ri* :state :potentio-vector :wait-until-update t))
  (when (null (send *fetch* :look-at-hand :rarm))
    (format t "cannot look at my hand.~%"))
  (send *ri* :angle-vector (send *fetch* :angle-vector) time))
(defun rotate-wrist-r (angle &key (time 3000) (wait t))
  (send *fetch* :rarm :wrist-r :joint-angle (+ angle (send *fetch* :rarm :wrist-r :joint-angle)))
  (send *ri* :angle-vector (send *fetch* :angle-vector) time)
  (when wait (send *ri* :wait-interpolation)))
;; should be used only when torso up
(defun move-torso (angle &key (time 3000) (wait t))
  (send *fetch* :torso :waist-z :joint-angle (+ angle (send *fetch* :torso :waist-z :joint-angle)))
  (send *ri* :angle-vector (send *fetch* :angle-vector) time)
  (when wait (send *ri* :wait-interpolation)))
(defun write-to-file(val filename)
  (with-open-file (out filename
		       :direction :output
		       :if-exists :append
		       :if-does-not-exist :create)
		  (princ (format nil "~A" val) out)))
;; normal-vector: convert (normal vector from coords origin to plane) from world coordinates to coords coordinates. e.g. this method can calculate normal vector from gripper to some planes at gripper coordinates. Norm of returned vector is distance between plane and coords, direction of returned vector is normal vector.
;; (setq *pl* (make-plane :normal #f(0 0 1) :point #f(0 0 700)))
;; (setq *co* (send (send *fetch* :rarm :end-coords) :copy-worldcoords))
;; (normal-vector *pl* *co*)
;; visualize: (objects (list *fetch* *co*))
(defun normal-vector (plane coords)
  (let ((pl (copy-object plane)) (co (copy-object coords)))
    (transform (v- (send pl :foot (send co :pos)) (send co :pos))
               (send co :rot))))
(defun arrow-on-gripper ()
  (unless (boundp '*fetch*)
    (error "set *fetch* first !!~%"))
  (load "models/arrow-object")
  (setq *fetch-ec* (send (arrow) :newcoords (send (send *fetch* :rarm :end-coords) :copy-worldcoords)))
  (send (send *fetch* :rarm :end-coords) :assoc *fetch-ec*)
  (objects (list *fetch* *fetch-ec*)))
(defun subscribe-effort ()
  (ros::subscribe "joint_states" sensor_msgs::JointState #'(lambda (x) (if (> (length (send x :effort)) 2) (print (send *fetch* :calc-force-from-joint-torque :rarm (send x :effort))) nil)) 10))
